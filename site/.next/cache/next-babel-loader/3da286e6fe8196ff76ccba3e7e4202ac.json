{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"C:\\\\Users\\\\wojtalam\\\\Workspace\\\\Github\\\\arc-keystone5\\\\site\\\\lib\\\\authetication.js\";\nvar __jsx = React.createElement;\nimport React, { Component, createContext, useContext } from 'react';\nimport { withApollo } from 'react-apollo';\nimport gql from 'graphql-tag';\n/**\n * AuthContext\n * -----------\n * This is the base react context instance. It should not be used\n * directly but is exported here to simplify testing.\n */\n\nexport const AuthContext = createContext();\n/**\n * useAuth\n * -------\n * A hook which provides access to the AuthContext\n */\n\nexport const useAuth = () => useContext(AuthContext);\nconst userFragment = `\n  id\n`;\n/**\n * AuthProvider\n * ------------\n * AuthProvider is a component which keeps track of the user's\n * authenticated state and provides methods for managing the auth state.\n */\n\nclass AuthProviderClass extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"setUserData\", user => {\n      this.setState({\n        isInitialising: false,\n        isLoading: false,\n        isAuthenticated: !!user,\n        user\n      });\n    });\n\n    _defineProperty(this, \"checkSession\", async () => {\n      // Avoid an extra re-render\n      const {\n        isLoading\n      } = this.state;\n\n      if (!isLoading) {\n        this.setState({\n          isLoading: true\n        });\n      }\n\n      return this.props.client.query({\n        query: gql`\n          query {\n            authenticatedUser {\n              ${userFragment}\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache'\n      }).then(({\n        data: {\n          authenticatedUser\n        },\n        error\n      }) => {\n        if (error) {\n          throw error;\n        }\n\n        this.setUserData(authenticatedUser);\n      }).catch(error => {\n        console.error(error);\n        this.setState({\n          error,\n          isLoading: false\n        });\n        throw error;\n      });\n    });\n\n    _defineProperty(this, \"signin\", async ({\n      email,\n      password\n    }) => {\n      this.setState({\n        error: null,\n        isLoading: true\n      }); // NOTE: We are not capturing the `token` here on purpose; The GraphQL API\n      // will set a `keystone.sid` cookie on its domain, which will be\n      // automatically read for each subsequent query.\n\n      return this.props.client.mutate({\n        mutation: gql`\n          mutation signin($email: String, $password: String) {\n            authenticateUserWithPassword(email: $email, password: $password) {\n              item {\n                ${userFragment}\n              }\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache',\n        variables: {\n          email,\n          password\n        }\n      }).then(async ({\n        data: {\n          authenticateUserWithPassword\n        },\n        error\n      }) => {\n        if (error) {\n          throw error;\n        } // Ensure there's no old unauthenticated data hanging around\n\n\n        await this.props.client.resetStore();\n\n        if (authenticateUserWithPassword && authenticateUserWithPassword.item) {\n          this.setUserData(authenticateUserWithPassword.item);\n        }\n      }).catch(error => {\n        console.error(error);\n        this.setState({\n          error,\n          isLoading: false\n        });\n        throw error;\n      });\n    });\n\n    _defineProperty(this, \"signout\", async () => {\n      this.setState({\n        error: null,\n        isLoading: true\n      });\n      return this.props.client.mutate({\n        mutation: gql`\n          mutation {\n            unauthenticateUser {\n              success\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache'\n      }).then(async ({\n        data: {\n          unauthenticateUser\n        },\n        error\n      }) => {\n        if (error) {\n          throw error;\n        } // Ensure there's no old authenticated data hanging around\n\n\n        await this.props.client.resetStore();\n\n        if (unauthenticateUser && unauthenticateUser.success) {\n          this.setUserData(null);\n        }\n      }).catch(error => {\n        console.error(error);\n        this.setState({\n          error,\n          isLoading: false\n        });\n        throw error;\n      });\n    });\n\n    this.state = {\n      user: props.initialUserValue,\n      isLoading: true\n    };\n  }\n\n  componentDidMount() {\n    this.checkSession();\n  }\n\n  render() {\n    const {\n      user,\n      isLoading,\n      isAuthenticated\n    } = this.state;\n    return __jsx(AuthContext.Provider, {\n      value: {\n        isAuthenticated,\n        isLoading,\n        signin: this.signin,\n        signout: this.signout,\n        user\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 153\n      },\n      __self: this\n    }, this.props.children);\n  }\n\n}\n\nexport const AuthProvider = withApollo(AuthProviderClass);","map":{"version":3,"sources":["C:/Users/wojtalam/Workspace/Github/arc-keystone5/site/lib/authetication.js"],"names":["React","Component","createContext","useContext","withApollo","gql","AuthContext","useAuth","userFragment","AuthProviderClass","constructor","props","user","setState","isInitialising","isLoading","isAuthenticated","state","client","query","fetchPolicy","then","data","authenticatedUser","error","setUserData","catch","console","email","password","mutate","mutation","variables","authenticateUserWithPassword","resetStore","item","unauthenticateUser","success","initialUserValue","componentDidMount","checkSession","render","signin","signout","children","AuthProvider"],"mappings":"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","sourcesContent":["import React, { Component, createContext, useContext } from 'react';\nimport { withApollo } from 'react-apollo';\nimport gql from 'graphql-tag';\n\n/**\n * AuthContext\n * -----------\n * This is the base react context instance. It should not be used\n * directly but is exported here to simplify testing.\n */\nexport const AuthContext = createContext();\n\n/**\n * useAuth\n * -------\n * A hook which provides access to the AuthContext\n */\nexport const useAuth = () => useContext(AuthContext);\n\nconst userFragment = `\n  id\n`;\n\n/**\n * AuthProvider\n * ------------\n * AuthProvider is a component which keeps track of the user's\n * authenticated state and provides methods for managing the auth state.\n */\nclass AuthProviderClass extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      user: props.initialUserValue,\n      isLoading: true,\n    };\n  }\n\n  componentDidMount() {\n    this.checkSession();\n  }\n\n  setUserData = user => {\n    this.setState({\n      isInitialising: false,\n      isLoading: false,\n      isAuthenticated: !!user,\n      user,\n    });\n  };\n\n  checkSession = async () => {\n    // Avoid an extra re-render\n    const { isLoading } = this.state;\n    if (!isLoading) {\n      this.setState({ isLoading: true });\n    }\n\n    return this.props.client\n      .query({\n        query: gql`\n          query {\n            authenticatedUser {\n              ${userFragment}\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache',\n      })\n      .then(({ data: { authenticatedUser }, error }) => {\n        if (error) {\n          throw error;\n        }\n        this.setUserData(authenticatedUser);\n      })\n      .catch(error => {\n        console.error(error);\n        this.setState({ error, isLoading: false });\n        throw error;\n      });\n  };\n\n  signin = async ({ email, password }) => {\n    this.setState({ error: null, isLoading: true });\n    // NOTE: We are not capturing the `token` here on purpose; The GraphQL API\n    // will set a `keystone.sid` cookie on its domain, which will be\n    // automatically read for each subsequent query.\n    return this.props.client\n      .mutate({\n        mutation: gql`\n          mutation signin($email: String, $password: String) {\n            authenticateUserWithPassword(email: $email, password: $password) {\n              item {\n                ${userFragment}\n              }\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache',\n        variables: { email, password },\n      })\n      .then(async ({ data: { authenticateUserWithPassword }, error }) => {\n        if (error) {\n          throw error;\n        }\n        // Ensure there's no old unauthenticated data hanging around\n        await this.props.client.resetStore();\n        if (authenticateUserWithPassword && authenticateUserWithPassword.item) {\n          this.setUserData(authenticateUserWithPassword.item);\n        }\n      })\n      .catch(error => {\n        console.error(error);\n        this.setState({ error, isLoading: false });\n        throw error;\n      });\n  };\n\n  signout = async () => {\n    this.setState({ error: null, isLoading: true });\n    return this.props.client\n      .mutate({\n        mutation: gql`\n          mutation {\n            unauthenticateUser {\n              success\n            }\n          }\n        `,\n        fetchPolicy: 'no-cache',\n      })\n      .then(async ({ data: { unauthenticateUser }, error }) => {\n        if (error) {\n          throw error;\n        }\n        // Ensure there's no old authenticated data hanging around\n        await this.props.client.resetStore();\n        if (unauthenticateUser && unauthenticateUser.success) {\n          this.setUserData(null);\n        }\n      })\n      .catch(error => {\n        console.error(error);\n        this.setState({ error, isLoading: false });\n        throw error;\n      });\n  };\n\n  render() {\n    const { user, isLoading, isAuthenticated } = this.state;\n    return (\n      <AuthContext.Provider\n        value={{\n          isAuthenticated,\n          isLoading,\n          signin: this.signin,\n          signout: this.signout,\n          user,\n        }}\n      >\n        {this.props.children}\n      </AuthContext.Provider>\n    );\n  }\n}\n\nexport const AuthProvider = withApollo(AuthProviderClass);\n"]},"metadata":{},"sourceType":"module"}